package se.liu.imt.mi.eee.db.xmldb;

import java.io.IOException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.xml.namespace.QName;

import org.apache.xmlbeans.XmlCursor;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.XmlOptions;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.output.DOMOutputter;
import org.json.JSONException;
import org.json.JSONObject;
import org.openehr.binding.XMLBinding;
import org.openehr.binding.XMLBindingException;
import org.openehr.rm.common.changecontrol.Contribution;
import org.openehr.rm.common.generic.AuditDetails;
import org.openehr.rm.common.generic.PartyProxy;
import org.openehr.rm.datatypes.quantity.datetime.DvDateTime;
import org.openehr.rm.datatypes.text.DvText;
import org.openehr.rm.support.identification.HierObjectID;
import org.openehr.rm.support.identification.ObjectRef;
import org.openehr.rm.support.identification.ObjectVersionID;
import org.openehr.rm.support.identification.UID;
import org.openehr.schemas.v1.AUDITDETAILS;
import org.openehr.schemas.v1.DVCODEDTEXT;
import org.openehr.schemas.v1.OBJECTREF;
import org.openehr.schemas.v1.OBJECTVERSIONID;
import org.openehr.schemas.v1.ORIGINALVERSION;
import org.openehr.terminology.SimpleTerminologyService;
import org.restlet.data.Status;
import org.restlet.resource.ResourceException;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xmldb.api.base.Collection;
import org.xmldb.api.base.CompiledExpression;
import org.xmldb.api.base.Resource;
import org.xmldb.api.base.ResourceIterator;
import org.xmldb.api.base.ResourceSet;
import org.xmldb.api.base.XMLDBException;
import org.xmldb.api.modules.TransactionService;
import org.xmldb.api.modules.XMLResource;
import org.xmldb.api.modules.XQueryService;

import se.liu.imt.mi.eee.db.SharedXQueries;
import se.liu.imt.mi.eee.db.EHRDatabaseReadInterface;
import se.liu.imt.mi.eee.db.EHRDatabaseWriteInterface;
import se.liu.imt.mi.eee.structure.AttestableVersionedObjectListItem;
import se.liu.imt.mi.eee.structure.EEEConstants;
import se.liu.imt.mi.eee.structure.VersionedObjectListItem;
import se.liu.imt.mi.eee.structure.XmlHelper;
import se.liu.imt.mi.eee.trigger.ContributionTrigger;
import se.liu.imt.mi.eee.utils.Util;
import se.liu.imt.mi.ehr.x2010.eeeV1.CONTRIBUTION;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;

public class EHRXMLDBHandler extends SharedXQueries implements EEEConstants, EHRDatabaseReadInterface<Node, Node>, EHRDatabaseWriteInterface<Node> {

	protected Collection ehrRoot, contributionsRoot;
	protected String ehrCollectionName, contributionCollectionName;

	//protected XPathQueryService ehrIndependentXpathQueryService;
	protected boolean autoGenerateContributionDescriptions = false;
	protected XMLDBHelper dbHelper;

	protected XQueryService contributionXqueryService; // split read & write into two services
	//protected XUpdateQueryService contributionXUpdateQueryService; // split read & write into two services
	protected XQueryService ehrXQueryService; 
	protected ContributionTrigger<Contribution> trigger;
	
	protected CompiledExpression compiledQuery_fetchTransaction;
	protected CompiledExpression compiledQuery_LatestContribution;
	protected CompiledExpression compiledQuery_ContributionsDescendingList;
	protected CompiledExpression compiledQuery_WriteContribution;
	protected CompiledExpression compiledQuery_GetContribution;

	protected CompiledExpression compiledQuery_VersionedObject;
	protected CompiledExpression compiledQuery_VersionedObject_all_version_ids;
	protected CompiledExpression compiledQuery_WriteVersion;
	
	protected XMLBinding xmlBinding;
	
	

	/**
	 * 
	 * @param autoGenerateContributionDescriptions if set to true, then 
	 * descriptions for contributions will be autogenerated by adding up
	 * the descriptions and some medatata (change type & object type) from
	 * all included objects AUDIT_DETAILS.description. 
	 * If on the other hand a specific contribution description is provided,
	 * then that will be used instead. IF the parameter is set to false, 
	 * then a null/void contribution description will remain null/void.
	 * @throws Exception 
	 * @throws XMLBindingException 

	 */
	public EHRXMLDBHandler(boolean autoGenerateContributionDescriptions, XMLDBHelper dbHelper, String ehrCollectionName, String contributionCollectionName, ContributionTrigger<Contribution> trigger, XMLBinding xmlBinding) throws Exception {
		this.autoGenerateContributionDescriptions = autoGenerateContributionDescriptions;
		this.dbHelper = dbHelper;
		this.ehrCollectionName = ehrCollectionName;
		this.contributionCollectionName = contributionCollectionName;
		this.trigger = trigger;
		
		//TODO: Add indexes to the EHR collection
		//IndexManagementService ehrIndexService = (IndexManagementService) ehrRoot.getService("IndexManagementService", "1.0");
		//ehrIndexService.createIndex(arg0, arg1, arg2, arg3)

		// Configure the XML <-> Java conversion
		this.xmlBinding = xmlBinding;		

		
		// *************** CONTRIBUTION QUERIES *************** 

		// Create the collection to store the Contributions
		contributionsRoot = dbHelper.createChildCollection(dbHelper.getRootCollection(), contributionCollectionName);
		
		// For read only
		contributionXqueryService = dbHelper.getXQueryService(contributionsRoot);
		setXQNamespaces(contributionXqueryService);
		contributionXqueryService.declareVariable("contrib_id", "dummy-value-to-make-first-compile-work");

		compiledQuery_fetchTransaction = contributionXqueryService.compile(QX_FETCH_TRANSACTION);
		compiledQuery_LatestContribution = contributionXqueryService.compile(XQ_LATEST_CONTRIBUTION_TIME_AND_ID_AS_JSON);		
		compiledQuery_ContributionsDescendingList = contributionXqueryService.compile(XQ_CONTRIBUTIONS_DESCENDING_LIST);		
		compiledQuery_GetContribution = contributionXqueryService.compile(XQ_GET_CONTRIBUTION);
		compiledQuery_WriteContribution = contributionXqueryService.compile(XQ_WRITE_CONTRIBUTION);
				
		// *************** EHR/VERSION QUERIES *************** 

		// Create the collection to store the EHRs
		ehrRoot = dbHelper.createChildCollection(dbHelper.getRootCollection(), ehrCollectionName);
		
		ehrXQueryService = dbHelper.getXQueryService(ehrRoot);
		setXQNamespaces(ehrXQueryService);
		
		compiledQuery_VersionedObject = ehrXQueryService.compile(XQ_VERSIONED_OBJECT);		
		compiledQuery_VersionedObject_all_version_ids = ehrXQueryService.compile(XQ_VERSIONED_OBJECT_ALL_VERSION_IDS);
		compiledQuery_WriteVersion = ehrXQueryService.compile(XQ_WRITE_VERSION );
		
	}

	protected void setXQNamespaces(XQueryService xqserv) throws XMLDBException {
		xqserv.setNamespace("v1", EEEConstants.SCHEMA_OPENEHR_ORG_V1);
		xqserv.setNamespace("xsi", EEEConstants.SCHEMA_XSI);
		xqserv.setNamespace("eee", EEEConstants.SCHEMA_EEE_OPENEHR_EXTENSION);
	}

	/**
	 * A simplified constructor for development, debugging, utility scripts etc. 
	 * Defaults:<br/>
	 * ehrCollectionName = "EHR"<br/>
	 * contributionCollectionName = "Contributions"<br/>
	 * ContributionTrigger = null, thus no triggers will be sent 
	 * @param autoGenerateContributionDescriptions
	 * @param dbHelper
	 * @throws Exception
	 */
//	public EHRXMLDBHandler(boolean autoGenerateContributionDescriptions, XMLDBHelper dbHelper) throws Exception {
//		this(autoGenerateContributionDescriptions, dbHelper, "EHR", "Contributions", null);
//	}

	/* (non-Javadoc)
	 * @see se.liu.imt.mi.eee.db.xmldb.EHRDatabaseReadInterface#getCurrentDatabaseTimeAsISODateTimeString()
	 */
	public String getCurrentDatabaseTimeAsISODateTimeString() throws IOException {
		return dbHelper.getCurrentDatabaseTimeAsISODateTimeString();
	}

	/**
	 * 
	 * @param committer
	 * @param ehrId
	 * @param systemId
	 * @param objectList it is assumed that the items in the list have already 
	 * 		  been validated (e.g. against archetypes, templates etc) before 
	 * 		  calling this method
	 * @param optionalContributionDescription
	 * @param optionalSuggestedContributionID
	 * @return
	 * @throws Exception 
	 * @throws Exception 
	 */
	public Contribution commitContributionOfOriginalVersions(PartyProxy committer, String ehrId, String systemId,
			List<? extends VersionedObjectListItem<Node>> incomingObjectList, DvText optionalContributionDescription, UID optionalSuggestedContributionID) throws Exception{

		// First check if an EHR object with this id exists
		Resource ehrDoc = ehrRoot.getResource(ehrId);
		// Check if this EHR exists
		if (ehrDoc == null) {
			throw new IllegalArgumentException("The EHR with ID: "+ehrId+" in system "+systemId+" does not exist ");
		}

//		List<VersionedObjectListItem<Node>> objectList;
//		final String errmess = "This EHRDatabaseWriter ("+this.getClass().getCanonicalName()+") only accepts VersionedObjectListItem<Node> objects";
//		if (incomingObjectList instanceof VersionedObjectListItem<?> && incomingObjectList.get(0) instanceof Node) {
//			try {
//				objectList =  (List<VersionedObjectListItem<Node>>) incomingObjectList;
//			} catch (Exception e) {
//				throw new ResourceException(Status.SERVER_ERROR_NOT_IMPLEMENTED, errmess + "- could not cast incoming list to List<VersionedObjectListItem<Node>>");
//			}
//		} else {
//			throw new ResourceException(Status.SERVER_ERROR_NOT_IMPLEMENTED, errmess);
//		}
		
		List<VersionedObjectListItem<Node>> objectList =  (List<VersionedObjectListItem<Node>>) incomingObjectList;
		
		// CURRENTLY DISABLED - FIXME: if we do not trust calling code, then we would
		// place calls to semantic validation of incoming objectList here (as the Contribution Builder classes do)

		
		// Set up variables to compute change_type (and description if none was given) 
		// for entire contribution. 		
		Set<AuditChangeType> includedChangeTypes = new HashSet<AuditChangeType>();
		
		// Set up a form datatype to store relationship between archetype ID and versioned object
		//Form archetypesUsed = new Form();
		
		String contributionDescriptionString = "";
		boolean generateContributionDescription = (optionalContributionDescription==null && autoGenerateContributionDescriptions);
		
		// ** Loop through objectList a first time (outside transaction handling)
		for (Iterator<VersionedObjectListItem<Node>> iterator = objectList.iterator(); iterator.hasNext();) {
			// - Create/update suitable IDs for versioned objects
			VersionedObjectListItem<Node> listItem = iterator.next();
			
			if(listItem instanceof AttestableVersionedObjectListItem<?>) throw new org.apache.commons.lang.NotImplementedException("Handling of AttestableVersionedObjectListItem<?> is not implemented yet");
			
			// Remember which change types we have seen in the loop:
			includedChangeTypes.add(listItem.getAuditChangeType());

			// Check lifecycle state against change type (throws exceptions if faulty)
			checkLifecycleStateAgainstChangeType(listItem, listItem.getAuditChangeType());
			
			AuditChangeType listItemChangeType = 
				checkVersioniIdsAgainstChangeType(ehrId, systemId, listItem);

			// Add to aggregated contribution description
			String listItemAuditDetailsDescription = "";
			if (listItem.getAuditDetailsDescription() != null){
				listItemAuditDetailsDescription = listItem.getAuditDetailsDescription().toString();
			}
			contributionDescriptionString += listItemAuditDetailsDescription +"("+ listItemChangeType.name() + " of " +listItem.getVersionableObjectType().name()+ ") ";

			// Analyze contained archetypes<archetype_id>
			/* In XML look for all things with the structure:
			<archetype_id><value>openEHR-EHR-ADMIN_ENTRY.admission.v1</value></archetype_id>
			*/
			
//			archAsString = listItem.getData().toString();
			
//			XmlObject dataAsXMLobj = XmlObject.Factory.parse(listItem.getData());
//			QNameSet qns = 
//			XmlObject[] selectedNodes = dataAsXMLobj.selectAttributes(arg0)
			
//			String detectedArchetype = ...;
//			archetypesUsed.add(new Parameter(detectedArchetype, listItem.getTempID()))  ;
			
		} // ** End of first iteration
		
		Contribution contributionToReturn;	
		
		// >>> Start transaction on contrib DB
		TransactionService contribTrans = dbHelper.createTransaction(contributionsRoot);
		TransactionService ehrTrans = null; // Needs to be defined before try/catch
		contribTrans.begin();

		try {
			// Get a timestamp
			String contributionTimestamp = dbHelper.getCurrentDatabaseTimeAsISODateTimeString();		
			DvDateTime contributionTimestampAsDvDateTime = new DvDateTime(contributionTimestamp);
			
			// Check if optionalSuggestedContributionID was provided and is free
			UID contribUID;
			if (optionalSuggestedContributionID != null) {
				contribUID = optionalSuggestedContributionID;			
			} else {
				// No id given in method call, thus create one
				contribUID = generateUID();
			}
			boolean idAlreadyTaken = checkIfContributionIDAlredyExists(contribUID);
			// It there are ID collisions generate new UIDs and loop until a free ID is found
			while (idAlreadyTaken) {
				contribUID = generateUID();
				idAlreadyTaken = checkIfContributionIDAlredyExists(contribUID);
			}
			// Now we have a valid Contribution ID (contribUID)
			
			// Create an OBJECTREF xmlObject pointing to contribUID
			OBJECTREF objRefToContribution = OBJECTREF.Factory.newInstance(XmlHelper.getXMLoptions2());
			objRefToContribution.addNewId().setValue(contribUID.getValue());
			objRefToContribution.setNamespace(systemId);
			objRefToContribution.setType("CONTRIBUTION");
			
			// Create an OBJECTREF array to hold OBJECTREFs to all versions in contribution
			ArrayList<OBJECTREF> arrayListOfReferencesToIncludedversions = new ArrayList<OBJECTREF>();
			// and a Set to do the same for creation of our return object
			Set<ObjectRef> setOfJavaVersionObjectReferences = new HashSet<ObjectRef>();
			
			// >>> Start transaction on EHR DB
			ehrTrans = dbHelper.createTransaction(ehrRoot);
			ehrTrans.begin();
					
			// Loop through each item in objectList
			for (Iterator<VersionedObjectListItem<Node>> iterator = objectList.iterator(); iterator.hasNext();) {
				// - Create/update suitable IDs for versioned objects
				VersionedObjectListItem<Node> listItem = iterator.next();
				AuditChangeType listItemChangeType = listItem.getAuditChangeType();
				
				// TODO: Check if synthesis also should create new container
				VersionableObjectType containerType = checkExsistenceAndTypeOfObjectContainer(ehrId, listItem.getSuggested_version_uid().objectID());
				if (listItemChangeType.equals(AuditChangeType.creation)) {
					// Make sure that a VERSIONED_OBJECT with that name is not already present 
					if (containerType != null) throw new Exception("The object ID "+listItem.getSuggested_version_uid().objectID()+" was already used, the UID generation is probably faulty");
					// a new VERSIONED_OBJECT (AuditChangeType.creation) thus create version container
					createVersionedObjectContainer(ehrId, listItem.getSuggested_version_uid().objectID(), listItem.getVersionableObjectType(), contributionTimestamp);				
				} else {
					// the change type is not creation, so a VERSIONED_OBJECT should exist...
					if (containerType == null) {
						throw new IllegalArgumentException("You may not use an AuditChangeType:"+listItem.getAuditChangeType().name()+" on a VERSIONED_OBJECT that does not yet exist");
					}
					// ...and it should be intended to be filled with VERSIONs of the same type
					if (containerType != listItem.getVersionableObjectType()) {
						throw new IllegalArgumentException("You may not a an object of type: "+listItem.getVersionableObjectType().name()+" to an existing VERSIONED_OBJECT of type: "+containerType.name());
					}
					// TODO: possibly also check latest_version here (or in writeVersion(...))
				}
				ORIGINALVERSION completeVersionAsXML = ORIGINALVERSION.Factory.newInstance(XmlHelper.getXMLoptions2());
				
				// Create and then add/update contribution reference (including timestamp)	
				AuditDetails auDetail = new AuditDetails(systemId, committer, 
						contributionTimestampAsDvDateTime,
						listItemChangeType.getAsDvCodedText(), 
						listItem.getAuditDetailsDescription(),
						SimpleTerminologyService.getInstance());
				
//			OriginalVersion<Object> oVerAsJavaObject = new OriginalVersion<Object>(
//					listItem.getSuggested_version_uid(),
//					listItem.getPreceding_version_uid(), 
//					new Object(), 
//					listItem.getVersionLifecycleState().asDvCodedText(),
//					auDetail, 
//					new ObjectRef(new HierObjectID(contribUID.getValue()), systemId, "CONTRIBUTION"),
//					null, null, null, 
//					SimpleTerminologyService.getInstance());
				
				completeVersionAsXML.setCommitAudit((AUDITDETAILS)xmlBinding.bindToXML(auDetail));
				completeVersionAsXML.setContribution(objRefToContribution);
				if (listItem.getPreceding_version_uid() != null) {
					completeVersionAsXML.addNewPrecedingVersionUid().setValue(listItem.getPreceding_version_uid());				
				}
				OBJECTVERSIONID objVerId = OBJECTVERSIONID.Factory.newInstance(XmlHelper.getXMLoptions2());
				objVerId.setValue(listItem.getSuggested_version_uid().getValue());
				//objVerId.changeType(OBJECTVERSIONID.type);
				completeVersionAsXML.setUid(objVerId);
								
				XmlObject dataObj = completeVersionAsXML.addNewData();

				if (listItem.getData() != null) { // can be null if deleted

					//System.out.println("EHRXMLDBHandler.commitContributionOfOriginalVersions(getBaseURI) > " +listItem.getData().getBaseURI());
					//System.out.println("EHRXMLDBHandler.commitContributionOfOriginalVersions(getNodeName) > " +listItem.getData().getNodeName());
					
					Node dataObjNode = dataObj.getDomNode();
					// skip surrounding tags:
					NodeList arr = listItem.getData().getFirstChild().getChildNodes();
					//System.out.println("EHRXMLDBHandler.commitContributionOfOriginalVersions() getChildNodes().getLength(): "+ arr.getLength());
					// Loop and add child elements one by one
					for (int i = 0; i < arr.getLength(); i++) {
						if (arr.item(i).getNodeType() == Node.ELEMENT_NODE) {
							Node imported = dataObjNode.getOwnerDocument().importNode(arr.item(i), true);
							dataObjNode.appendChild(imported);
						}									
					}
					// FIXME: now also add attributes that were lost (xsi:type & arch id)
					// FIXME: gives a nullpointexception here if the archetype is not embedded in a composition. Give a smarter error message than nullpointerexception.
					NamedNodeMap map = listItem.getData().getFirstChild().getAttributes();
					for (int i = 0; i < map.getLength(); i++) {
						Node imported = dataObjNode.getOwnerDocument().importNode(map.item(i), true);
						dataObjNode.getAttributes().setNamedItem(imported);		
					}
					
				}
				completeVersionAsXML.setLifecycleState((DVCODEDTEXT)xmlBinding.bindToXML(listItem.getVersionLifecycleState().asDvCodedText()));

				//System.out.println("EHRXMLDBHandler.commitContributionOfOriginalVersions()" +completeVersionAsXML.xmlText());
				
				// FIXME: loop over and add OtherInputVersionUids
				//completeVersionAsXML.addNewOtherInputVersionUids();
				
				// TODO: Calculate signature (requires openEHR deciding on canonical form first) 
				// completeVersionAsXML.setSignature(...)
				
				// TODO: Switch to assert if code is slow
				//assert(completeVersionAsXML.validate());
//				ArrayList<XmlError> errorList = new ArrayList<XmlError>();
//				if(!completeVersionAsXML.validate(XmlHelper.generateXMLoptionsForEHRRootDocumentWithErrorList(errorList))) {
//					
//					String errorListAsString = "Error list:\n";
//					for (int i = 0; i < errorList.size(); i++)
//				      {
//				          XmlError error = (XmlError)errorList.get(i);
//				          errorListAsString += "Message: " + error.getMessage() + "\n";
//				          errorListAsString += "Location of invalid XML: " + 
//				              error.getCursorLocation().xmlText() + "\n";
//				      }					
//					throw new Exception("XML validation of VERSIONED_OBJECT failed! "+errorListAsString);
//				}
				
				// - Store item in container		
				writeVersion(ehrId, listItem.getSuggested_version_uid(), listItem.getVersionableObjectType(), completeVersionAsXML);
				
				// Create an OBJECTREF to the recently added VERSION and add to the list
				OBJECTREF oref = OBJECTREF.Factory.newInstance(XmlHelper.getXMLoptions2());
				oref.addNewId().setValue(listItem.getSuggested_version_uid().getValue());
				oref.setNamespace(systemId);
				oref.setType("VERSION");
				arrayListOfReferencesToIncludedversions.add(oref);
				setOfJavaVersionObjectReferences.add(new ObjectRef(listItem.getSuggested_version_uid(), systemId, "VERSION"));
			}
			
			// Create AuditDetails for Contribution Object
			AuditDetails contribAuDetails = constructAuditDetailsForTheContributionObject(
					committer, systemId, optionalContributionDescription,
					contributionTimestampAsDvDateTime, contributionDescriptionString,
					generateContributionDescription, includedChangeTypes);
			
			// Create Contribution Object
			// new Contribution(contribUID, setOfVersions, contributionAuditDetails);			
			CONTRIBUTION contributionAsXMLObject = CONTRIBUTION.Factory.newInstance(XmlHelper.getXMLoptions2());
			contributionAsXMLObject.addNewUid().setValue(contribUID.getValue()); 
			contributionAsXMLObject.setAudit((AUDITDETAILS) xmlBinding.bindToXML(contribAuDetails));
			OBJECTREF[] ora = (OBJECTREF[]) Array.newInstance(OBJECTREF.class, arrayListOfReferencesToIncludedversions.size());
			
			int i = 0;
			for (Iterator<OBJECTREF> iterator = arrayListOfReferencesToIncludedversions
					.iterator(); iterator.hasNext();) {
				OBJECTREF objectRef = (OBJECTREF) iterator.next();
				//contrib.insertNewVersions(objectRef)
				//contrib.setVersionsArray(i, objectRef);
				ora[i] = objectRef;
				i++;
			}

			contributionAsXMLObject.setVersionsArray(ora);
			
			// TODO: Switch to assert if code is slow
			//assert(contrib.validate());
//			ArrayList<XmlError> errorList = new ArrayList<XmlError>();
//			if(!contrib.validate(XmlHelper.generateXMLoptionsForContributionRootDocumentWithErrorList(errorList))) {
//				
//				String errorListAsString = "Error list:\n";
//				for (int j = 0; j < errorList.size(); j++)
//			      {
//			          XmlError error = (XmlError)errorList.get(j);
//			          errorListAsString += "Message: " + error.getMessage() + "\n";
//			          errorListAsString += "Location of invalid XML: " + 
//			              error.getCursorLocation().xmlText() + "\n";
//			      }					
//				throw new Exception("XML validation of CONTRIBUTION failed! "+errorListAsString);
//			}
			//if(!contrib.validate()) throw new Exception("XML validation failed!");
			
			// Store Contribution Object
			writeContribution(ehrId, contribUID, contributionAsXMLObject, contribTrans);
			
			contributionToReturn = new Contribution(new HierObjectID(contribUID.getValue()), setOfJavaVersionObjectReferences, contribAuDetails);
			
			// Later? -> (possibly update timestamp of each included versioned object and of the contribution if above approach does not work)
			// <<< End transactions x2
			ehrTrans.commit();
			contribTrans.commit();
			
			// Notify contribution trigger handler if triggering is switched on
			if (trigger != null) trigger.notifyTriggerHandler(ehrId, contributionToReturn); 
			// if (trigger != null) trigger.notifyTriggerHandler(ehrId, contributionToReturn, archetypesUsed); //TODO: Add archetype info
			
		} catch (Exception e) {
			// Roll back transactions if Exception occurred
			ehrTrans.rollback();
			contribTrans.rollback();
			throw e;
		}
		

		return contributionToReturn; 
		
	}

	private AuditChangeType checkVersioniIdsAgainstChangeType(String ehrID, String systemId,
			VersionedObjectListItem listItem) throws Exception {
		
		AuditChangeType listItemChangeType = listItem.getAuditChangeType();
		switch (listItemChangeType) {

		case creation:
			if (listItem.getPreceding_version_uid() != null) {
				throw new IllegalArgumentException("If the change_type is 'creation', then the 'preceding_version_uid' field must be null");
			}
			listItem.setSuggested_version_uid(new ObjectVersionID(generateUID().getValue(), systemId, "1"));
			break;

		case deleted:
			if (listItem.getData() != null) {
				throw new IllegalArgumentException("If the change_type is 'deleted', then the data field must be null");
			}
			listItem.setSuggested_version_uid(checkPreviousVersionUidExistenceAndGenerateNext(ehrID, listItem.getPreceding_version_uid(), systemId));
			break;

		case amendment:			
		case modification:
			listItem.setSuggested_version_uid(checkPreviousVersionUidExistenceAndGenerateNext(ehrID, listItem.getPreceding_version_uid(), systemId));
			// TODO: Re-check conflict upon submission or include this part in transaction?
			break;			

		case attestation:
			throw new Exception("Attestation should not be done by calling this method, use the method 'attestObject' instead.");
			//break; (unreachable due to throw)

		case synthesis:	
			// TODO and FIXME: Check if this should work just as for creation (for now throw up below...)
		case unknown:	
			throw new org.apache.commons.lang.NotImplementedException("Handling of "+listItemChangeType+" not implemented yet");
			//break;

		default:
			assert false;
			throw new Exception("Implementation error - unknown change_type was used"); // Should never be reached
		} // End of switch statement
		return listItemChangeType;
	}

	private void createVersionedObjectContainer(String ehrId, UID suggestedObjectUid,
			VersionableObjectType versionedObjectType, String timeAsString) throws XMLDBException {
		
		//Store in DB (using xquery update?)
		
		String query = 
				"update insert \n" + 
				"	<eee:versioned_objects xsi:type='eee:VERSIONED_"+versionedObjectType.name()+"' >" + // "+XmlHelper.XQUERY_NAMESPACE_DECLARATIONS_AS_XML_ATTRIBUTES+"
				"		<eee:uid><v1:value>"+suggestedObjectUid+"</v1:value></eee:uid>" +
				"		<eee:time_created>"+timeAsString+"</eee:time_created>" +
				"		<eee:owner_id>"+ehrId+"</eee:owner_id>" +
				"	</eee:versioned_objects> \n" +
				"into //eee:EHR[eee:ehr_id/v1:value/text()='"+ehrId+"']";
		
		//System.out.println("EHRXMLDBHandler.createVersionedObjectContainer() will run update query:\n"+query);
		ehrXQueryService.query(query);
	
	}

	/**
	 * 
	 * @param objectID
	 * @return returns null if the container does not exist
	 * @throws Exception is thrown if the container is of an unknown type (should not happen if DB is correctly managed)
	 */
	protected VersionableObjectType checkExsistenceAndTypeOfObjectContainer(String ehrId, UID objectID) throws Exception {
		// FIXME TODO implement type check!
		ResourceSet rset = ehrXQueryService.query(
				"for $ehr in //eee:EHR[eee:ehr_id/v1:value/text()='"+ehrId+"'] " +
				"let $v_obj := $ehr//*[eee:uid/v1:value/text()='"+objectID.getValue()+"'] " +
				"return $v_obj");
		ResourceIterator it = rset.getIterator();
		if (it.hasMoreResources()) {
			XMLResource r = (XMLResource) it.nextResource();
			String s = r.getContentAsDOM().getFirstChild().getAttributes().getNamedItemNS(EEEConstants.SCHEMA_XSI, "type").getNodeValue();
			//TODO: speed up code below if slow (using lastindexof "_"?) 
			return VersionableObjectType.valueOf(s.replace("eee:VERSIONED_", ""));
		} else {
			return null;
		}
	}

	/**
	 * This check should preferrably be called inside a transaction if one
	 * wants to avoid inconsistencies.
	 * @param suggestedContributionID
	 * @return true if the ID was already taken
	 * @throws XMLDBException
	 */
	private boolean checkIfContributionIDAlredyExists(
			UID suggestedContributionID) throws XMLDBException {
		contributionXqueryService.declareVariable("contrib_id", suggestedContributionID.getValue());
		ResourceSet response = contributionXqueryService.execute(compiledQuery_fetchTransaction);
		ResourceIterator it = response.getIterator();
		return it.hasMoreResources();
		//return response.getSize() > 0;
	}

	
	// TODO: Create methods for import and merge too (not only original versions as below)
	
	// TODO: Possibly break out validation etc and possibly move some parts to ContributionResource/DBWrite 

	private ObjectVersionID checkPreviousVersionUidExistenceAndGenerateNext(String ehrID,
			String precedingVersionUidAsString, String systemId) throws Exception {
		
		if (precedingVersionUidAsString == null) throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST, "preceding version id is missing");
		
		ObjectVersionID precedingVersionUid = new ObjectVersionID(precedingVersionUidAsString); // TODO: add nice errormessage on parse error
		
		// Get a list of comitted version IDs for this object		
		String objectID = precedingVersionUid.objectID().getValue();
		List<String> versionList = getVersionedObject_all_version_ids(ehrID, objectID);

		ObjectVersionID nextVersionUID = Util.generateNextVersionUID(precedingVersionUid, systemId);

		// Check that the previous_version actually exists - otherwise throw exception
		if (!versionList.contains(precedingVersionUid.getValue())) {
			throw new ResourceException(Status.CLIENT_ERROR_PRECONDITION_FAILED, "The preceding Version that you tried to update/modify does not exist in this system") ;// TODO: Check if this status code is ok for the purpose
		}
		
		// Check that the nextVersionUID does not exist - otherwise throw exception
		if (versionList.contains(nextVersionUID.getValue())) {
			throw new ResourceException(Status.CLIENT_ERROR_PRECONDITION_FAILED, "The new Version that you tried add already exist in this system") ;// TODO: Check if this status code is ok for the purpose
		}
			
		return nextVersionUID;
	}

	private AuditDetails constructAuditDetailsForTheContributionObject(
			PartyProxy committer, String systemId,
			DvText optionalContributionDescription,
			DvDateTime temporaryContributionTimeStamp,
			String contributionDescriptionString,
			boolean generateContributionDescription,
			Set<AuditChangeType> includedChangeTypes) throws Exception {
		// ** Construct audit details for the contribution as a whole: **

		AuditChangeType contributionChangeType = AuditChangeType.unknown;

		if (includedChangeTypes.isEmpty()) {
			assert false;
			throw new Exception("Error: The set of changes types was empty");
		} 

		if (includedChangeTypes.size() == 1){
			// Only one kind of change, so use that...
			contributionChangeType = (AuditChangeType) includedChangeTypes.toArray()[0];
		} 

		DvText contributioniAuditDetailsDescription = null; 

		if (generateContributionDescription) {
			contributionDescriptionString += "(autogenerated contribution description)";
			contributioniAuditDetailsDescription = new DvText(contributionDescriptionString);
		} else {
			// Set to given desc (that might also be null)
			contributioniAuditDetailsDescription = optionalContributionDescription;
		}

		AuditDetails contributionAuditDetails = new AuditDetails(systemId, committer, 
				temporaryContributionTimeStamp, 
				contributionChangeType.getAsDvCodedText(), 
				contributioniAuditDetailsDescription,
				SimpleTerminologyService.getInstance());
		return contributionAuditDetails;
	}



	private void checkLifecycleStateAgainstChangeType(
			VersionedObjectListItem listItem,
			AuditChangeType listItemChangeType) throws IllegalArgumentException {
		if (listItemChangeType == AuditChangeType.deleted){
			if (listItem.getVersionLifecycleState() != VersionLifecycleState.deleted) {
				throw new IllegalArgumentException("Error: VersionLifecycleState was set to '"+listItem.getVersionLifecycleState().name()+"' in the call when change type was set 'deleted'");
			}
		} else {
			// AuditChangeType is not == deleted
			if (listItem.getVersionLifecycleState() == VersionLifecycleState.deleted) {
				throw new IllegalArgumentException("Error: VersionLifecycleState was set to 'deleted' in the call when change type was "+listItemChangeType.name()+" (not 'deleted')");					
			}
		}
	}



	/* (non-Javadoc)
	 * @see se.liu.imt.mi.eee.db.xmldb.EHRDatabaseWriteInterface#writeContribution(java.lang.String, org.openehr.rm.support.identification.UID, T, org.xmldb.api.modules.TransactionService)
	 */
	protected void writeContribution(String ehrID, UID contributionID, XmlObject xmlObject, TransactionService transaction) throws Exception{
		
		// TODO: remove contributionID from call if no longer needed.
		
//		Collection ehrSpecificContributionCollection = contributionsRoot.getChildCollection(ehrID);
//		
//		if (ehrSpecificContributionCollection == null) {
//			ehrSpecificContributionCollection = dbHelper.createChildCollection(contributionsRoot, ehrID);
//			System.out.println("EHRXMLDBHandler.writeContribution() WARNING: autogenerated missing CONTRIBUTION collectionfor EHR "+ehrID);
//		} 				
//		Resource contribRes = ehrSpecificContributionCollection.getResource(contributionID.getValue());
//		if (contribRes != null) {
//			throw new Exception("Implementation error: A contribution with ID "+contributionID.getValue()+" has already been comitted earlier!");
//		}
//		contribRes = ehrSpecificContributionCollection.createResource(contributionID.getValue(), XMLResource.RESOURCE_TYPE);

		XmlOptions xopt = XmlHelper.getXMLoptions2();
//		xopt.setSaveInner();
//		xopt.setSaveNoXmlDecl();
//		xopt.setSaveOuter();
		xopt.setSaveSyntheticDocumentElement(new QName(SCHEMA_EEE_OPENEHR_EXTENSION, "contribution"));

		
//		System.out.println("EHRXMLDBHandler.writeContribution( ++++ )\n"+xmlObject.xmlText(xopt));

//		Node newDomNode = xmlObject.newDomNode(xopt).getFirstChild();
		
		// OLD 
//		((XMLResource)contribRes).setContentAsDOM(newDomNode);
//		ehrSpecificContributionCollection.storeResource(contribRes);
		
		// NEW CODE START (TODO: Add same style as in writeVersion())

		String contributionAsXml = xmlObject.xmlText(xopt);
		//Node contributionAsXml = newDomNode;  // TODO: check if using node directly is better than stringifying...
		//System.out.println("EHRXMLDBHandler.writeContribution() ----------- "+ contributionAsXml);		
		
		contributionXqueryService.setCollection(contributionsRoot);
		contributionXqueryService.declareVariable("ehrID", ehrID);
		contributionXqueryService.declareVariable("contributionAsXml", contributionAsXml);
		
		// TODO: This is a temporary workaround instead of the above
//		String moddedString = writeContributionQueryString.replace("declare variable $ehrID as xs:string external; ", "");	
//		moddedString = moddedString.replace("$ehrID", "'"+ehrID+"'");			
		String moddedString = XQ_WRITE_CONTRIBUTION.replace("declare variable $contributionAsXml external; ", "");	
		moddedString = moddedString.replace("$contributionAsXml", contributionAsXml);	
//		System.out.println("EHRXMLDBHandler.writeContribution() moddedString:\n"+moddedString);
		contributionXqueryService.query(moddedString);
		contributionXqueryService.execute(compiledQuery_WriteContribution);
//		contributionXqueryService.query(writeContributionQueryString);
		// Don't try this, it doesn't work with eXist DB: contributionXqueryService.queryResource(ehrID, moddedString);
		
//		String newWriteContributionQueryString = 	
//			"update insert <?xml version=\"1.0\" encoding=\"UTF-8\" ?> "+contributionAsXml+" into /contributions return "; // [@ehr_id=$"+ehrID+"] ";
//		System.out.println("EHRXMLDBHandler.writeContribution() newWriteContributionQueryString:\n"+newWriteContributionQueryString);
//		contributionXUpdateQueryService.updateResource(ehrID, newWriteContributionQueryString);
//		contributionXqueryService.queryResource(ehrID, newWriteContributionQueryString);
		
		// contributionXqueryService.query(writeContributionQueryString);

//		// Test/debug printing
//		ResourceIterator it = response.getIterator();
//		while (it.hasMoreResources()) {
//			Resource res = (Resource) it.nextResource();
//			System.out.println("EHRXMLDBHandler.writeContribution() res --> "+res.toString());
//		}	
		
		// NEW CODE END
		
	}

	protected void writeVersion(String ehrID, ObjectVersionID ovid, VersionableObjectType versionableObjectType,
			XmlObject xmlObject) throws Exception {

		// TODO: if(not first VERSION in this VERSIONED_OBJECT) Check if the EHR contains this VERSIONED_OBJECT and check it's type
		// TODO: Should also check if ObjectVersionID (ovid) still is free before writing
		
		String objectID = ovid.objectID().getValue();
			
		XmlOptions xopt = new XmlOptions(XmlHelper.getXMLoptionsForVERSION()); // TODO: Check differences between impl/sugg
//		xopt.setSaveNamespacesFirst();
//		xopt.setSaveNoXmlDecl();
		Node versionAsXml = xmlObject.newDomNode(xopt);
		String versionAsXmlString = xmlObject.xmlText(xopt);

//		System.out.println("EHRXMLDBHandler.writeVersion()_________" + versionAsXmlSring);

		ehrXQueryService.declareVariable("ehrID", ehrID);
		ehrXQueryService.declareVariable("objectID", objectID);
		
//		// TODO: This is more like how it should be approached		
//		ehrXQueryService.declareVariable("versionAsXml", versionAsXml);
//		ehrXQueryService.execute(compiledQuery_WriteVersion);

		// TODO: This is a temporary workaround instead of the above
		String moddedString = XQ_WRITE_VERSION.replace(" declare variable $versionAsXml external; ", "");	
		moddedString = moddedString.replace("$versionAsXml", versionAsXmlString);	
		//System.out.println("EHRXMLDBHandler.writeVersion() moddedString:"+moddedString);
		ehrXQueryService.query(moddedString);
		
	}
	

	public static void setXsiTypeOnFirstNode(XmlObject xmlObject, String typeName) {
		XmlCursor cursor = xmlObject.newCursor();
		cursor.toFirstChild();
		cursor.insertAttributeWithValue(new QName(SCHEMA_XSI, "type"), typeName);
	}
	

	/* (non-Javadoc)
	 * @see se.liu.imt.mi.eee.db.xmldb.EHRDatabaseReadInterface#getVersionedObject(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
	 */
	public Node getVersionedObject(String ehrID, String objectID, String systemID, String treeID) throws XMLDBException {
		ehrXQueryService.declareVariable("ehrID", ehrID);
		ehrXQueryService.declareVariable("fullVersionID", objectID+"::"+systemID+"::"+treeID);	
		ResourceIterator rit = ehrXQueryService.execute(compiledQuery_VersionedObject).getIterator();
		if (rit.hasMoreResources()) {
			return ((XMLResource)rit.nextResource()).getContentAsDOM();			
		} else {
			return null;			
		}		
	}


	/* (non-Javadoc)
	 * @see se.liu.imt.mi.eee.db.xmldb.EHRDatabaseReadInterface#getVersionedObject_all_version_ids(java.lang.String, java.lang.String)
	 */
	public List<String> getVersionedObject_all_version_ids(String ehrID, String objectID) throws XMLDBException {		
		
		ehrXQueryService.declareVariable("ehrID", ehrID);
		ehrXQueryService.declareVariable("objectID", objectID);	
		ResourceIterator rit = ehrXQueryService.execute(compiledQuery_VersionedObject_all_version_ids).getIterator();
		
		ArrayList<String> versionIdList= new ArrayList<String>();
		while (rit.hasMoreResources()) {
			Resource r = rit.nextResource();
			versionIdList.add(r.getContent().toString());
		}
		return versionIdList;
	}

//	public String decodeLastDoubleColon(String resourceName) {
//		// TODO: check if resourceName.replace(target, replacement) would be better
//		int splitPoint = resourceName.lastIndexOf(DOUBLE_COLON_REPLACEMENT);
//		String versionIdString =  resourceName.substring(0, splitPoint) + "::"
//			+ resourceName.substring(splitPoint + DOUBLE_COLON_REPLACEMENT.length());
//		return versionIdString;
//	}
//	
//	public String decodeAndGetPartAfterLastDoubleColon(String resourceName) {
//		// TODO: check if resourceName.replace(target, replacement) would be better
//		int splitPoint = resourceName.lastIndexOf(DOUBLE_COLON_REPLACEMENT);
//		return resourceName.substring(splitPoint + DOUBLE_COLON_REPLACEMENT.length());
//	}
//	
//	public String encodeLastDoubleColon(String resourceName) {
//		// TODO: check if resourceName.replace(target, replacement) would be better
//		int splitPoint = resourceName.lastIndexOf("::");
//		String versionIdString =  resourceName.substring(0, splitPoint) + DOUBLE_COLON_REPLACEMENT
//			+ resourceName.substring(splitPoint + 2);
//		return versionIdString;
//	}



	public Date getCurrentDatabaseTime() throws Exception {
		return dbHelper.getCurrentDatabaseTime();
	}

	/**
	 * @return Returns a DOM Node containing the requested contribution if it exists, if no such contribution exists, then null is returned. 
	 */
	public Node getContribution(String ehrID, String contributionID) {
		try {
			contributionXqueryService.setCollection(contributionsRoot);
			contributionXqueryService.declareVariable("ehrID", ehrID);			
			contributionXqueryService.declareVariable("contributionID", contributionID);	
			ResourceSet rset = contributionXqueryService.execute(compiledQuery_GetContribution);
			ResourceIterator rit = rset.getIterator();

			// Return null if empty
			if (!rit.hasMoreResources()) return null;

			Node contribNode = ((XMLResource) rit.nextResource()).getContentAsDOM();			
			return contribNode;
			
		} catch (XMLDBException e) {
			e.printStackTrace();
			throw new ResourceException(Status.SERVER_ERROR_INTERNAL, "ERROR: Could not get contribution from database", e);
		}
	}
	
	/**
	 * Set start=1 and stop=1 if you just want the latest contribution
	 * 
	 * @param ehrID
	 * @param start
	 * @param stop
	 * @return returns a list of XML nodes containting CONTRIBUTIONs or null if
	 *         there are no contributions for the ehrID
	 * @throws XMLDBException
	 */
	public List<Node> listContributionsDescending(String ehrID, int start, int end) {
		System.out.println("EHRXMLDBHandler.listContributionsDescending() start="+start+" end="+end);

		
// ///// Below is the query formatted as it would be in a pure xQuery client, text within (: smileys :) are comments
//		  
//		  declare default element namespace "http://schemas.openehr.org/v1";
//		  declare namespace eee = "http://www.imt.liu.se/mi/ehr/2010/EEE-v1.xsd"; 
//		  declare namespace v1 = "http://schemas.openehr.org/v1";
//		  
//		  (: declare variable $start external; :) 
//		  declare variable $start {1};
//		  
//		  (: declare variable $end external; :) declare variable $end {5};
//		  
//		  let $result := for $contrib in //eee:CONTRIBUTION 
//		  (: ONLY NEEDED WHEN RETURNING JSON BELOW: let $uid := $contrib/eee:uid/v1:value/text() :)
//		
//		  let $time := $contrib/eee:audit/v1:time_committed/v1:value/text() let
//		  $modtime := xs:dateTime($time) order by $modtime descending 
//		  return $contrib 
//		
//		  (: TO RETURN TIME AND UID AS JSON IT WOULD BE: return concat('{"time_committed": "', $modtime, '", "uid": "', $uid,'"}') :)
//		  
//		  for $y at $pos in $result where ($pos ge $start) and ($pos le $end)
//		  return $y
		
		ArrayList<Node> contribList = null;
		
		try {
			contributionXqueryService.setCollection(contributionsRoot);
			contributionXqueryService.declareVariable("ehrID", ehrID);			
			contributionXqueryService.declareVariable("start", start);
			contributionXqueryService.declareVariable("end", end);
			ResourceSet rset = contributionXqueryService.execute(compiledQuery_ContributionsDescendingList);
	
			ResourceIterator rit = rset.getIterator();

			// Return null if empty
			if (!rit.hasMoreResources()) return null;

			contribList = new ArrayList<Node>();
			while (rit.hasMoreResources()) {
				contribList.add(((XMLResource) rit.nextResource()).getContentAsDOM());
			}

		} catch (XMLDBException e) {
			throw new ResourceException(Status.SERVER_ERROR_INTERNAL, "ERROR: Could not list contributions", e);
		}
	return contribList;

	
	}

	public void createEHR(String ehrId, String systemId) 
			throws IllegalArgumentException, Exception {
		TransactionService trans = null;
		try {
			trans = dbHelper.createTransaction(ehrRoot);
			trans.begin();
			// Check if EHR already exists
			if (ehrRoot.getResource(ehrId) != null) {
				trans.rollback();
				throw new IllegalArgumentException("The ehr_id "+ehrId+" is already in use, try another one");
			} else {
			// Create EHR root XML object
			se.liu.imt.mi.ehr.x2010.eeeV1.EHR ehrXmlObject = constructEhrRootXMLObject(ehrId, systemId);

			// Todo: check if timestamping can be done more efficiently if neccesary
			ehrXmlObject.addNewTimeCreated().setValue(getCurrentDatabaseTimeAsISODateTimeString());

			// Store EHR root XML object
			XMLResource newEhrRes = (XMLResource) ehrRoot.createResource(ehrId, XMLResource.RESOURCE_TYPE);
			// Later possibly update timestamp here instead
			Node newDomNode = ehrXmlObject.newDomNode(XmlHelper.getXMLoptionsForEHRRootDocument());
			System.out.println("EHRXMLDBHandler.createEHR() -- "+ehrXmlObject.xmlText(XmlHelper.getXMLoptionsForEHRRootDocument()));
			newEhrRes.setContentAsDOM(newDomNode);
			System.out.println("EHRXMLDBHandler.createEHR() --- will store");
			ehrRoot.storeResource(newEhrRes);
			
			// Create a contribution root for this EHR (TODO: maybe opened an inner transaction for this)
			XMLResource newContribRes = (XMLResource) contributionsRoot.createResource(ehrId, XMLResource.RESOURCE_TYPE);			
			// TODO: Move this to published XML schema (and use xmlBeans?)
			Element contribRoot = new Element("contributions", EEEConstants.SCHEMA_EEE_OPENEHR_EXTENSION);
			contribRoot.setAttribute("ehr_id", ehrId);
			Document contribRootDoc = new Document(contribRoot);
			DOMOutputter domOut = new DOMOutputter();
			newContribRes.setContentAsDOM(domOut.output(contribRootDoc));
			contributionsRoot.storeResource(newContribRes);
			
			// Commit the entire EHR creation
			trans.commit();
			}
		} catch (Exception e) {
			e.printStackTrace();
			// Roll back on errors
			try {
				trans.rollback();
				// Oh my, the rollback can also throw exceptions!
			} catch (Exception e2) {
				throw e2;
			}			
			throw e;
		}		
	}


	/**
	 * 
	 * @param ehrID id of the ehr to find latest contribution time & id for. 
	 * @return returns a json object containing two fields time_committed (string formatted as ISO datetime) and uid (string, containing e.g. a UUID). Returns null if no contributions exist for this EHR.
	 */
	public JSONObject getContributionsLatest(String ehrID) {
//		System.out.println("getContributionsLatest() ehrID="+ehrID);
		String xresString;

		try {				
//			Collection childCollection = contributionsRoot.getChildCollection(ehrID);
//			if (childCollection == null) {
//				return null;
//			}
//			System.out.println("EHRXMLDBHandler.getContributionsLatest("+ehrID+"): " );
//			String [] childNameArray = childCollection.listResources();
//			for (String name : childNameArray) {
//				System.out.println("EHRXMLDBHandler.getContributionsLatest() "+name);
//			}
			
			contributionXqueryService.setCollection(contributionsRoot);
			contributionXqueryService.declareVariable("ehrID", ehrID);			
			ResourceSet rset = contributionXqueryService.execute(compiledQuery_LatestContribution);

			//System.out.println("EHRXMLDBHandler.getContributionsLatest(rset.getResource(0))");
			ResourceIterator rit = rset.getIterator();

			// Return null if empty
			if (!rit.hasMoreResources()) return null;

			XMLResource xres= ((XMLResource) rit.nextResource());
			xresString = xres.getContent().toString();
			// System.out.println("EHRXMLDBHandler.getContributionsLatest(xresString)"+xresString);

		} catch (XMLDBException e) {
			throw new ResourceException(Status.SERVER_ERROR_INTERNAL, "ERROR: Could not find data for latest contribution", e);
		}

		JSONObject resultingJsonObject;
		try {
			resultingJsonObject = new JSONObject(xresString);
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			throw new ResourceException(Status.SERVER_ERROR_INTERNAL, "ERROR: Could not parse json, maybe the database query is not correctly formatted or configured", e);
		}
		return resultingJsonObject;		
	}

	public String createEHR(String systemId) throws Exception {
		UID id = generateUID();
		createEHR(id.getValue(), systemId);
		return id.getValue();
	}



}

